-- File: display.vhd
-- Generated by MyHDL 0.8
-- Date: Tue Jun 18 08:49:10 2013


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_08.all;

entity display is
    port (
        clk: in std_logic;
        fastClk: in std_logic;
        leftbutton: in std_logic;
        resetbutton: in std_logic;
        rightbutton: in std_logic;
        rows: out unsigned(7 downto 0);
        col_sel: out unsigned(2 downto 0)
    );
end entity display;


architecture MyHDL of display is




type t_enum_st_1 is (
    START,
    LOSE
);

signal left_in: unsigned(4 downto 0);
signal right_out2: unsigned(4 downto 0);
signal sel_out2: unsigned(3 downto 0);
signal isThereCollision: std_logic;
signal disp_col: unsigned(2 downto 0);
signal my_state: t_enum_st_1;
signal pos: unsigned(2 downto 0);
signal sel_out: unsigned(3 downto 0);
signal random_hat: unsigned(4 downto 0);
signal right_out: unsigned(4 downto 0);
signal count_for_lose: unsigned(4 downto 0);
signal rand_new_out: unsigned(2 downto 0);
signal rand_old: unsigned(2 downto 0);
signal rand_rand_count: unsigned(2 downto 0);
signal rand_rand_clk_sep: std_logic;
signal positionBuf_count: unsigned(2 downto 0);
signal lowerBuf_a: unsigned(3 downto 0);
signal lowerBuf_c: unsigned(3 downto 0);
signal lowerBuf_b: unsigned(3 downto 0);
signal lowerBuf_e: unsigned(3 downto 0);
signal lowerBuf_d: unsigned(3 downto 0);
signal upperBuf_a: unsigned(3 downto 0);
signal upperBuf_c: unsigned(3 downto 0);
signal upperBuf_b: unsigned(3 downto 0);
signal upperBuf_e: unsigned(3 downto 0);
signal upperBuf_d: unsigned(3 downto 0);

begin




DISPLAY_CHANGECOL: process (fastClk) is
begin
    if rising_edge(fastClk) then
        if (disp_col = 4) then
            disp_col <= to_unsigned(0, 3);
        else
            disp_col <= (disp_col + 1);
        end if;
    end if;
end process DISPLAY_CHANGECOL;


DISPLAY_ASSIGN: process (sel_out, pos, sel_out2, disp_col) is
begin
    col_sel <= disp_col;
    rows(7-1 downto 0) <= unsigned'(sel_out2(3-1 downto 0) & sel_out);
    if (pos = disp_col) then
        rows(7) <= '1';
    else
        rows(7) <= sel_out2(3);
    end if;
end process DISPLAY_ASSIGN;


DISPLAY_FSM: process (clk, resetbutton) is
begin
    if (resetbutton = '1') then
        left_in <= to_unsigned(0, 5);
        my_state <= START;
        count_for_lose <= to_unsigned(0, 5);
    elsif rising_edge(clk) then
        if (my_state = START) then
            left_in <= random_hat;
            if bool(isThereCollision) then
                my_state <= LOSE;
                left_in <= to_unsigned(31, 5);
            end if;
        else
            if (count_for_lose < 23) then
                left_in <= to_unsigned(31, 5);
                -- left_in.next[0] = 1
                -- left_in.next[1] = (not row[1] and not row[4]) or (not row[2] and row[3] and not row[4]) or (row[2] and not row[3] and not row[4]) or (row[0] and row[3]) or (row[0] and row[2])
                -- left_in.next[2] = (not row[4]) or (row[0] and row[3]) or (row[0] and row[4])
                -- left_in.next[3] = (not row[2] and not row[3] and not row[4]) or (not row[1] and row[2] and row[3] and not row[4]) or (row[1] and not row[3] and not row[4]) or (row[0] and row[2] and row[4])
                -- left_in.next[4] = 1
            elsif (count_for_lose < 31) then
                left_in <= to_unsigned(0, 5);
            else
                my_state <= START;
            end if;
            count_for_lose <= ((count_for_lose + 1) mod 32);
        end if;
    end if;
end process DISPLAY_FSM;


DISPLAY_UPPERBUF_SHIFTER: process (clk, resetbutton) is
begin
    if (resetbutton = '1') then
        upperBuf_a <= to_unsigned(0, 4);
        upperBuf_c <= to_unsigned(0, 4);
        upperBuf_b <= to_unsigned(0, 4);
        upperBuf_e <= to_unsigned(0, 4);
        upperBuf_d <= to_unsigned(0, 4);
    elsif rising_edge(clk) then
        upperBuf_a(4-1 downto 1) <= upperBuf_a(3-1 downto 0);
        upperBuf_a(0) <= left_in(0);
        upperBuf_b(4-1 downto 1) <= upperBuf_b(3-1 downto 0);
        upperBuf_b(0) <= left_in(1);
        upperBuf_c(4-1 downto 1) <= upperBuf_c(3-1 downto 0);
        upperBuf_c(0) <= left_in(2);
        upperBuf_d(4-1 downto 1) <= upperBuf_d(3-1 downto 0);
        upperBuf_d(0) <= left_in(3);
        upperBuf_e(4-1 downto 1) <= upperBuf_e(3-1 downto 0);
        upperBuf_e(0) <= left_in(4);
    end if;
end process DISPLAY_UPPERBUF_SHIFTER;


DISPLAY_UPPERBUF_SELECTOR: process (upperBuf_a, upperBuf_c, upperBuf_b, upperBuf_e, upperBuf_d, disp_col) is
begin
    if (disp_col = 0) then
        sel_out <= upperBuf_a;
    elsif (disp_col = 1) then
        sel_out <= upperBuf_b;
    elsif (disp_col = 2) then
        sel_out <= upperBuf_c;
    elsif (disp_col = 3) then
        sel_out <= upperBuf_d;
    elsif (disp_col = 4) then
        sel_out <= upperBuf_e;
    end if;
end process DISPLAY_UPPERBUF_SELECTOR;



right_out <= unsigned'(upperBuf_e(3) & upperBuf_d(3) & upperBuf_c(3) & upperBuf_b(3) & upperBuf_a(3));


DISPLAY_LOWERBUF_SHIFTER: process (clk, resetbutton) is
begin
    if (resetbutton = '1') then
        lowerBuf_a <= to_unsigned(0, 4);
        lowerBuf_c <= to_unsigned(0, 4);
        lowerBuf_b <= to_unsigned(0, 4);
        lowerBuf_e <= to_unsigned(0, 4);
        lowerBuf_d <= to_unsigned(0, 4);
    elsif rising_edge(clk) then
        lowerBuf_a(4-1 downto 1) <= lowerBuf_a(3-1 downto 0);
        lowerBuf_a(0) <= right_out(0);
        lowerBuf_b(4-1 downto 1) <= lowerBuf_b(3-1 downto 0);
        lowerBuf_b(0) <= right_out(1);
        lowerBuf_c(4-1 downto 1) <= lowerBuf_c(3-1 downto 0);
        lowerBuf_c(0) <= right_out(2);
        lowerBuf_d(4-1 downto 1) <= lowerBuf_d(3-1 downto 0);
        lowerBuf_d(0) <= right_out(3);
        lowerBuf_e(4-1 downto 1) <= lowerBuf_e(3-1 downto 0);
        lowerBuf_e(0) <= right_out(4);
    end if;
end process DISPLAY_LOWERBUF_SHIFTER;


DISPLAY_LOWERBUF_SELECTOR: process (lowerBuf_a, lowerBuf_c, lowerBuf_b, lowerBuf_e, lowerBuf_d, disp_col) is
begin
    if (disp_col = 0) then
        sel_out2 <= lowerBuf_a;
    elsif (disp_col = 1) then
        sel_out2 <= lowerBuf_b;
    elsif (disp_col = 2) then
        sel_out2 <= lowerBuf_c;
    elsif (disp_col = 3) then
        sel_out2 <= lowerBuf_d;
    elsif (disp_col = 4) then
        sel_out2 <= lowerBuf_e;
    end if;
end process DISPLAY_LOWERBUF_SELECTOR;



right_out2 <= unsigned'(lowerBuf_e(3) & lowerBuf_d(3) & lowerBuf_c(3) & lowerBuf_b(3) & lowerBuf_a(3));


DISPLAY_POSITIONBUF_SHIFTING: process (leftbutton, rightbutton) is
begin
    if bool(rightbutton) then
        if (positionBuf_count = 0) then
            positionBuf_count <= to_unsigned(4, 3);
        else
            positionBuf_count <= (positionBuf_count - 1);
        end if;
    elsif bool(leftbutton) then
        if (positionBuf_count = 4) then
            positionBuf_count <= to_unsigned(0, 3);
        else
            positionBuf_count <= (positionBuf_count + 1);
        end if;
    elsif  then
        null;
    end if;
end process DISPLAY_POSITIONBUF_SHIFTING;



pos <= positionBuf_count;


DISPLAY_RAND_DEC_DECODER: process (rand_new_out) is
begin
    if (rand_new_out = 0) then
        random_hat <= to_unsigned(1, 5);
    elsif (rand_new_out = 1) then
        random_hat <= to_unsigned(2, 5);
    elsif (rand_new_out = 2) then
        random_hat <= to_unsigned(4, 5);
    elsif (rand_new_out = 3) then
        random_hat <= to_unsigned(8, 5);
    elsif (rand_new_out = 4) then
        random_hat <= to_unsigned(16, 5);
    end if;
end process DISPLAY_RAND_DEC_DECODER;


DISPLAY_RAND_RAND_COUNTING: process (fastClk) is
begin
    if rising_edge(fastClk) then
        if (rand_rand_count /= 4) then
            rand_rand_count <= (rand_rand_count + 1);
        else
            rand_rand_count <= to_unsigned(0, 3);
        end if;
    end if;
end process DISPLAY_RAND_RAND_COUNTING;


DISPLAY_RAND_RAND_SHOWING: process (rand_rand_clk_sep) is
    variable a: integer;
begin
    if rising_edge(rand_rand_clk_sep) then
        if (rand_old = rand_rand_count) then
            a := to_integer(rand_rand_count + 1);
            if (a = 5) then
                a := 0;
            end if;
            rand_new_out <= to_unsigned(a, 3);
            rand_old <= to_unsigned(a, 3);
        else
            rand_new_out <= rand_rand_count;
            rand_old <= rand_rand_count;
        end if;
    end if;
end process DISPLAY_RAND_RAND_SHOWING;


DISPLAY_RAND_RAND_CLOCK_CUTTING: process (clk) is
begin
    if rising_edge(clk) then
        rand_rand_clk_sep <= stdl((not bool(rand_rand_clk_sep)));
    end if;
end process DISPLAY_RAND_RAND_CLOCK_CUTTING;


DISPLAY_COLLISION_CHECK: process (right_out2, pos) is
begin
    case pos is
        when "000" =>
            if bool(right_out2(0)) then
                isThereCollision <= '1';
            else
                isThereCollision <= '0';
            end if;
        when "001" =>
            if bool(right_out2(1)) then
                isThereCollision <= '1';
            else
                isThereCollision <= '0';
            end if;
        when "010" =>
            if bool(right_out2(2)) then
                isThereCollision <= '1';
            else
                isThereCollision <= '0';
            end if;
        when "011" =>
            if bool(right_out2(3)) then
                isThereCollision <= '1';
            else
                isThereCollision <= '0';
            end if;
        when "100" =>
            if bool(right_out2(4)) then
                isThereCollision <= '1';
            else
                isThereCollision <= '0';
            end if;
        when others =>
            isThereCollision <= '1';
    end case;
end process DISPLAY_COLLISION_CHECK;

end architecture MyHDL;
